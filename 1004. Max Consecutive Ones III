Given a binary array nums and an integer k, return the maximum number of consecutive 1's in the array if you can flip at most k 0's.

 

Example 1:

Input: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2
Output: 6
Explanation: [1,1,1,0,0,1,1,1,1,1,1]
Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.
Example 2:

Input: nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3
Output: 10
Explanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.
 

Constraints:

1 <= nums.length <= 105
nums[i] is either 0 or 1.
0 <= k <= nums.length



Soln:

Time complexity : O(N)
Space complexity : O(1)

class Solution {
public:
    int longestOnes(vector<int>& nums, int k) {
        int n=nums.size();
        int start=0,end=0,maxLen=0,currLen=0;
        while(start<n && end<n)
        {
            //increment the window size until our condition satisfies

            //if k is exhausted and there is no way to  flip the 0's to 1's then
            if(nums[end]==0 && k==0)
            {
                 // move start position to till where the k's count more than 0
                 while(start<n)
                 {
                    if(nums[start]==0)
                    {
                    k++;
                    start++;
                   // end=start;
                    break;
                    }
                    start++;
                 }
            }
            
            if(nums[end]==0 && k>0)   //if there is enough K's count then flip it and reduce k
            k--;

            currLen=end-start+1;

            if(k>=0)
            {
                maxLen=max(currLen,maxLen);
            }
            end++;
        }

        return maxLen;
    }
};
